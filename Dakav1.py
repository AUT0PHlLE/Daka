import asyncio
import random
import json
import os
import time
from datetime import datetime
from pyrogram import Client, filters
from pyrogram.enums import ChatType
from pyrogram.errors import UserNotParticipant, FloodWait, PeerIdInvalid

# ========== CONFIG ==========
API_ID = 4880420
API_HASH = "fe7c528c27d3993a438599063bc03a3b"
SESSIONS = []  # Will be loaded from devour.json
SUDO_USERS = [6836139884]
DELAY_RANGE = [4, 6]  # Changed to list for easy modification
DATA_FILE = "devour.json"
CURRENT_FILE = "Current.json"
PERSONAL_BOT = "im_bakabot"

# ========== SHARED STATE ==========
REPLY_TEXT1 = {}
REPLY_TEXT2 = {}
DEVOUR_STATE = {}
LAST_SCAN = {}
CURRENT_EXECUTIONS = {}  # Track currently running executions

def load_data():
    global REPLY_TEXT1, REPLY_TEXT2, LAST_SCAN, SESSIONS, DELAY_RANGE
    if os.path.exists(DATA_FILE):
        with open(DATA_FILE, "r") as f:
            data = json.load(f)
        REPLY_TEXT1 = {int(k): v for k, v in data.get("reply_text1", {}).items()}
        REPLY_TEXT2 = {int(k): v for k, v in data.get("reply_text2", {}).items()}
        LAST_SCAN = {int(k): v for k, v in data.get("last_scan", {}).items()}
        SESSIONS = data.get("sessions", [])
        DELAY_RANGE = data.get("delay_range", [4, 6])
    else:
        SESSIONS = []
        DELAY_RANGE = [4, 6]
        save_data()

def save_data():
    try:
        with open(DATA_FILE, "r") as f:
            data = json.load(f)
    except Exception:
        data = {
            "reply_text1": {},
            "reply_text2": {},
            "execution_logs": [],
            "last_scan": {},
            "sessions": [],
            "delay_range": [4, 6],
        }
    data["reply_text1"] = {str(k): v for k, v in REPLY_TEXT1.items()}
    data["reply_text2"] = {str(k): v for k, v in REPLY_TEXT2.items()}
    data["last_scan"] = {str(k): v for k, v in LAST_SCAN.items()}
    data["sessions"] = SESSIONS
    data["delay_range"] = DELAY_RANGE
    with open(DATA_FILE, "w") as f:
        json.dump(data, f, indent=2)

def update_current_json(user_id, chat_id, session_name, mode, count, total):
    """Update Current.json with execution progress"""
    if not os.path.exists(CURRENT_FILE):
        CURRENT_EXECUTIONS[user_id] = []
    else:
        try:
            with open(CURRENT_FILE, "r") as f:
                current_data = json.load(f)
            CURRENT_EXECUTIONS.update(current_data)
        except Exception:
            CURRENT_EXECUTIONS[user_id] = []

    if user_id not in CURRENT_EXECUTIONS:
        CURRENT_EXECUTIONS[user_id] = []

    # Find or create execution entry
    exec_entry = None
    for entry in CURRENT_EXECUTIONS[user_id]:
        if entry["chat_id"] == chat_id and entry["session_name"] == session_name:
            exec_entry = entry
            break

    if exec_entry is None:
        exec_entry = {
            "chat_id": chat_id,
            "session_name": session_name,
            "mode": mode,
            "count": count,
            "total": total,
            "timestamp": time.time(),
        }
        CURRENT_EXECUTIONS[user_id].append(exec_entry)
    else:
        exec_entry["count"] = count

    # Save to file
    with open(CURRENT_FILE, "w") as f:
        json.dump(CURRENT_EXECUTIONS, f, indent=2)

def remove_current_json(user_id, chat_id, session_name):
    """Remove execution from Current.json"""
    if user_id in CURRENT_EXECUTIONS:
        CURRENT_EXECUTIONS[user_id] = [
            e for e in CURRENT_EXECUTIONS[user_id]
            if not (e["chat_id"] == chat_id and e["session_name"] == session_name)
        ]
        if not CURRENT_EXECUTIONS[user_id]:
            del CURRENT_EXECUTIONS[user_id]

    with open(CURRENT_FILE, "w") as f:
        json.dump(CURRENT_EXECUTIONS, f, indent=2)

def load_current_json():
    """Load Current.json"""
    global CURRENT_EXECUTIONS
    if os.path.exists(CURRENT_FILE):
        try:
            with open(CURRENT_FILE, "r") as f:
                CURRENT_EXECUTIONS = json.load(f)
        except Exception:
            CURRENT_EXECUTIONS = {}
    else:
        CURRENT_EXECUTIONS = {}

def save_execution_log(chat_id, msg_links, texts, mode):
    try:
        with open(DATA_FILE, "r") as f:
            data = json.load(f)
    except Exception:
        data = {
            "reply_text1": {},
            "reply_text2": {},
            "execution_logs": [],
            "last_scan": {},
            "sessions": [],
            "delay_range": [4, 6],
        }
    log = {
        "chat_id": chat_id,
        "mode": mode,
        "texts": texts,
        "message_links": msg_links,
        "count": len(msg_links),
        "timestamp": time.time(),
    }
    data.setdefault("execution_logs", []).append(log)
    data["reply_text1"] = {str(k): v for k, v in REPLY_TEXT1.items()}
    data["reply_text2"] = {str(k): v for k, v in REPLY_TEXT2.items()}
    data["last_scan"] = {str(k): v for k, v in LAST_SCAN.items()}
    data["sessions"] = SESSIONS
    data["delay_range"] = DELAY_RANGE
    with open(DATA_FILE, "w") as f:
        json.dump(data, f, indent=2)

def owner_or_sudo(_, __, m):
    return m.from_user and (m.from_user.id in SUDO_USERS or m.outgoing)

sudo_filter = filters.create(owner_or_sudo)

def build_main_menu(state, has_scan):
    return (
        f"**üéØ Target:** {state['target_name']}\n"
        f"**Group ID:** `{state['chat_id']}`"
        f"{' | üíæ Scan loaded' if has_scan else ''}\n\n"
        "**Main Menu:**\n"
        "1Ô∏è‚É£ Scan all users (text1)\n"
        "2Ô∏è‚É£ Attack by message links\n"
        "3Ô∏è‚É£ Use last scan\n"
        "4Ô∏è‚É£ 2-text blast (/settext1 + /settext2)\n"
        "5Ô∏è‚É£ Temporary text blast\n"
        "6Ô∏è‚É£ Rob mode (/rob 200/150/100/50/1000)\n"
        "7Ô∏è‚É£ Attack a specific message from all accounts\n"
        "8Ô∏è‚É£ Delete all my messages from group\n"
        "9Ô∏è‚É£ Claim `/daily` from all accounts in @im_bakabot\n"
        "üîü Batch (send to a range of scanned users)\n"
        "Reply `1-10` or use /cancel"
    )

def parse_message_link(link):
    link = link.strip()
    if link.startswith("https://"):
        link = link.replace("https://", "", 1)
    if link.startswith("http://"):
        link = link.replace("http://", "", 1)
    if link.startswith("t.me/"):
        link = link[5:]
    parts = link.split("/")
    if len(parts) < 2:
        raise ValueError("Invalid link format")
    if parts[0] == "c":
        if len(parts) < 3:
            raise ValueError("Invalid /c/ link format")
        channel_id = int(parts[1])
        msg_id = int(parts[2])
        chat_id = int(f"-100{channel_id}")
        return chat_id, msg_id
    else:
        username = parts[0]
        msg_id = int(parts[1])
        return username, msg_id

async def add_new_session(apps, name, session_string):
    new_app = Client(
        name,
        api_id=API_ID,
        api_hash=API_HASH,
        session_string=session_string,
    )
    _attach_attack_method(new_app)
    register_handlers(new_app, apps)
    await new_app.start()
    apps.append(new_app)

async def remove_session(apps, name):
    idx = None
    for i, s in enumerate(SESSIONS):
        if s["name"] == name:
            idx = i
            break
    if idx is not None:
        for i, app in enumerate(apps):
            if app.name == name:
                try:
                    await app.stop()
                except Exception:
                    pass
                apps.pop(i)
                break
        SESSIONS.pop(idx)
        save_data()

async def run_parallel_attacks(app_list, chat_id, msg_id, text, times, cancel_event=None):
    async def attack_one(app):
        for _ in range(times):
            if cancel_event and cancel_event.is_set():
                break
            try:
                await app.send_message(chat_id, text, reply_to_message_id=msg_id)
                await asyncio.sleep(0.25)
            except FloodWait as e:
                if cancel_event and cancel_event.is_set():
                    break
                await asyncio.sleep(e.value)
            except Exception:
                break
    tasks = [asyncio.create_task(attack_one(a)) for a in app_list]
    try:
        await asyncio.gather(*tasks)
    except asyncio.CancelledError:
        for t in tasks:
            t.cancel()
        raise

def _attach_attack_method(app):
    async def send_spam_attack(chat_id, msg_id, text, times):
        for _ in range(times):
            try:
                await app.send_message(chat_id, text, reply_to_message_id=msg_id)
                await asyncio.sleep(0.25)
            except Exception:
                break
    app.send_spam_attack = send_spam_attack.__get__(app, Client)
    return app

def register_handlers(app, all_apps=None):

    @app.on_message(filters.command("devour") & sudo_filter & filters.private)
    async def devour_start(client, message):
        user_id = message.from_user.id
        DEVOUR_STATE[user_id] = {"step": "await_target"}
        await message.reply("üîó Send the group link (`https://t.me/...`), @username or chat id (-100...) of the target chat.")

    @app.on_message(filters.command("delay") & sudo_filter & filters.private)
    async def set_delay(client, message):
        global DELAY_RANGE
        parts = message.text.split()
        if len(parts) < 3:
            await message.reply(f"‚ùå **Usage:** `/delay <min> <max>`\n\nCurrent delay: `{DELAY_RANGE[0]}-{DELAY_RANGE[1]}` seconds")
            return
        try:
            min_delay = int(parts[1])
            max_delay = int(parts[2])
            if min_delay < 0 or max_delay < 0 or min_delay > max_delay:
                await message.reply("‚ùå Invalid values. Min and max must be positive, and min ‚â§ max.")
                return
            DELAY_RANGE = [min_delay, max_delay]
            save_data()
            await message.reply(f"‚úÖ Delay range updated to `{min_delay}-{max_delay}` seconds.")
        except ValueError:
            await message.reply("‚ùå Invalid input. Use numbers only.")

    @app.on_message(filters.command("current") & sudo_filter & filters.private)
    async def show_current(client, message):
        user_id = message.from_user.id
        load_current_json()
        
        if user_id not in CURRENT_EXECUTIONS or not CURRENT_EXECUTIONS[user_id]:
            await message.reply("‚ÑπÔ∏è No currently running executions.")
            return

        executions = CURRENT_EXECUTIONS[user_id]
        text = "**üìä Currently Running Executions:**\n\n"
        for idx, exec_data in enumerate(executions, 1):
            percentage = (exec_data["count"] / exec_data["total"] * 100) if exec_data["total"] > 0 else 0
            text += (
                f"`{idx}` | **Target:** `{exec_data['chat_id']}`\n"
                f"    **Session:** `{exec_data['session_name']}`\n"
                f"    **Mode:** `{exec_data['mode']}`\n"
                f"    **Progress:** `{exec_data['count']}/{exec_data['total']}` ({percentage:.1f}%)\n\n"
            )

        text += "Reply with the number to cancel that execution (e.g., `1` to cancel first)."
        state = DEVOUR_STATE.get(user_id)
        if state is None:
            state = {"step": "select_cancel"}
            DEVOUR_STATE[user_id] = state
        else:
            state["step"] = "select_cancel"

        await message.reply(text)

    @app.on_message(
        sudo_filter
        & filters.private
        & ~filters.command(
            [
                "devour",
                "settext1",
                "settext2",
                "help",
                "cancel",
                "stop",
                "joinchat",
                "addacc",
                "delacc",
                "delall",
                "claim",
                "delay",
                "current",
            ]
        )
    )
    async def devour_menu(client, message):
        user_id = message.from_user.id
        if user_id not in DEVOUR_STATE:
            return
        state = DEVOUR_STATE[user_id]
        text = message.text.strip()

        def ensure_cancel_event():
            if "cancel_event" not in state or not isinstance(state.get("cancel_event"), asyncio.Event):
                state["cancel_event"] = asyncio.Event()
            state.setdefault("background_task", None)

        # Handle cancel selection from /current
        if state["step"] == "select_cancel":
            if not text.isdigit():
                await message.reply("‚ùå Reply with a number.")
                DEVOUR_STATE.pop(user_id, None)
                return

            exec_num = int(text)
            load_current_json()
            
            if user_id not in CURRENT_EXECUTIONS or exec_num < 1 or exec_num > len(CURRENT_EXECUTIONS[user_id]):
                await message.reply("‚ùå Invalid selection.")
                DEVOUR_STATE.pop(user_id, None)
                return

            exec_data = CURRENT_EXECUTIONS[user_id][exec_num - 1]
            
            # Find the state for that execution and set cancel event
            for uid, st in DEVOUR_STATE.items():
                if (st.get("chat_id") == exec_data["chat_id"] and 
                    st.get("session_name") == exec_data["session_name"]):
                    cancel_event = st.get("cancel_event")
                    if cancel_event:
                        cancel_event.set()
                    bg = st.get("background_task")
                    if bg and isinstance(bg, asyncio.Task) and not bg.done():
                        try:
                            bg.cancel()
                        except Exception:
                            pass
                    break

            await message.reply(f"üõë Cancellation requested for execution #{exec_num}.")
            DEVOUR_STATE.pop(user_id, None)
            return

        # STEP 1: choose target chat
        if state["step"] == "await_target":
            chat_input = text
            try:
                if chat_input.startswith("https://t.me/") or chat_input.startswith("http://t.me/"):
                    chat = await client.get_chat(chat_input)
                else:
                    chat = await client.get_chat(chat_input)
                if not chat:
                    await message.reply("‚ùå Could not find that chat.")
                    DEVOUR_STATE.pop(user_id, None)
                    return

                try:
                    member = await client.get_chat_member(chat.id, "me")
                    if not member:
                        await message.reply("‚ùå Not a member. Join with /joinchat <invite link>.")
                        DEVOUR_STATE.pop(user_id, None)
                        return
                except UserNotParticipant:
                    await message.reply("‚ùå Not a member. Join with /joinchat <invite link>.")
                    DEVOUR_STATE.pop(user_id, None)
                    return

                scan = LAST_SCAN.get(chat.id)
                state.update(
                    {
                        "step": "main_menu",
                        "target_name": chat.title or str(chat.id),
                        "chat_id": chat.id,
                    }
                )
                menu = build_main_menu(state, scan is not None)
                await message.reply(menu)
            except PeerIdInvalid:
                await message.reply("‚ùå Peer ID invalid or unknown. Make sure this account joined the group.")
                DEVOUR_STATE.pop(user_id, None)
            except Exception as e:
                await message.reply(f"‚ùå Error accessing chat: {e}")
                DEVOUR_STATE.pop(user_id, None)
            return

        # STEP MAIN MENU
        if state["step"] == "main_menu":
            opt = text.lower()
            chat_id = state["chat_id"]

            # 1) Scan all users (text1)
            if opt == "1":
                state["step"] = "scanning"
                status = await message.reply(f"üîç Scanning all users in **{state['target_name']}**...")
                user_msgs = {}
                try:
                    async for msg in client.get_chat_history(chat_id):
                        if (
                            msg.from_user
                            and not msg.from_user.is_bot
                            and not getattr(msg.from_user, "is_deleted", False)
                        ):
                            if msg.from_user.id not in user_msgs:
                                user_msgs[msg.from_user.id] = msg.id
                except PeerIdInvalid:
                    await status.edit("‚ùå Peer ID invalid or not joined.")
                    DEVOUR_STATE.pop(user_id, None)
                    return
                last_count = len(user_msgs)
                LAST_SCAN[chat_id] = {
                    "user_msgs": user_msgs,
                    "count": last_count,
                    "timestamp": time.time(),
                }
                save_data()
                state["step"] = "await_count"
                state["user_msgs"] = user_msgs
                await status.edit(
                    f"‚úÖ Found **{last_count}** users.\n\nHow many to execute (1-{last_count})? Reply with a number."
                )
                return

            # 2) message-links attack
            if opt == "2":
                state["step"] = "await_links"
                await message.reply("üìé Send message links (one per line).")
                return

            # 3) use last scan
            if opt == "3":
                scan = LAST_SCAN.get(chat_id)
                if not scan or not scan.get("user_msgs"):
                    await message.reply("‚ùå No cached previous scan data. Use option 1 first.")
                    DEVOUR_STATE.pop(user_id, None)
                    return
                state["user_msgs"] = scan["user_msgs"]
                state["step"] = "await_count"
                await message.reply(
                    f"üíæ Loaded cached data (**{len(scan['user_msgs'])} users**).\n\nHow many to execute? Reply with number."
                )
                return

            # 4) 2-text blast
            if opt == "4":
                state["step"] = "wait_2text_prepare"
                await message.reply(
                    "üìù Set texts with `/settext1 <text>` and `/settext2 <text>`.\nWhen ready, reply with how many users to execute."
                )
                return

            # 5) temporary text (one-time)
            if opt == "5":
                state["step"] = "await_temptext"
                await message.reply(
                    "üìù Send `/temptext 1 <text>` for one reply, or `/temptext 2 <text>` for two identical replies per user."
                )
                return

            # 6) rob mode
            if opt == "6":
                state["step"] = "rob_select"
                await message.reply(
                    "üí∞ **Rob Mode**\n"
                    "1Ô∏è‚É£ /rob 200\n"
                    "2Ô∏è‚É£ /rob 150\n"
                    "3Ô∏è‚É£ /rob 100\n"
                    "4Ô∏è‚É£ /rob 50\n"
                    "5Ô∏è‚É£ /rob 1000\n"
                    "Reply with 1-5"
                )
                return

            # 7) attack a specific message from all accounts
            if opt == "7":
                state["step"] = "attack_message_link"
                await message.reply(
                    "üî• **Attack by Message Link**\nSend the target message link "
                    "(right-click/copy link from the user message)."
                )
                return

            # 8) delete all self messages from group
            if opt == "8":
                status = await message.reply("üóë Deleting all my messages from group...")
                deleted_count = 0
                async for msg in client.get_chat_history(chat_id):
                    if msg.from_user and msg.from_user.is_self:
                        try:
                            await client.delete_messages(chat_id, msg.id)
                            deleted_count += 1
                            await asyncio.sleep(0.1)
                        except Exception:
                            pass
                await status.edit(f"‚úÖ Done! Deleted {deleted_count} messages.")
                await message.reply("‚úÖ All bot messages removed from group.")
                DEVOUR_STATE.pop(user_id, None)
                return

            # 9) claim daily on @im_bakabot
            if opt == "9":
                await message.reply("‚è≥ Claiming `/daily` from all accounts in @im_bakabot...")
                failed = 0
                for sess in SESSIONS:
                    try:
                        temp_app = None
                        if all_apps:
                            for a in all_apps:
                                if a.name == sess["name"]:
                                    temp_app = a
                                    break
                        if temp_app is None:
                            temp_app = Client(
                                sess["name"],
                                api_id=API_ID,
                                api_hash=API_HASH,
                                session_string=sess["session_string"],
                            )
                            await temp_app.start()
                        await temp_app.send_message(PERSONAL_BOT, "/daily")
                        if all_apps is None or temp_app not in all_apps:
                            await temp_app.stop()
                        await asyncio.sleep(2)
                    except Exception:
                        failed += 1
                await message.reply(
                    f"‚úÖ `/daily` claimed in @im_bakabot.\nAccounts: {len(SESSIONS)}, Failed: {failed}"
                )
                DEVOUR_STATE.pop(user_id, None)
                return

            # 10) Batch range from scanned data
            if opt == "10":
                user_msgs = state.get("user_msgs")
                if not user_msgs:
                    scan = LAST_SCAN.get(chat_id)
                    if not scan or not scan.get("user_msgs"):
                        await message.reply("‚ùå No scan data available. Use option 1 to scan or option 3 to load last scan.")
                        DEVOUR_STATE.pop(user_id, None)
                        return
                    state["user_msgs"] = scan["user_msgs"]
                state["step"] = "batch_await_range"
                await message.reply(
                    "üì¶ Batch send setup:\n"
                    "Reply with a range in one of these formats:\n"
                    "`<start> <end>` (e.g. `1 500`) or a single number `<N>` (e.g. `500` meaning 1 to 500).\n"
                    "Indexing is 1-based and inclusive."
                )
                return

            await message.reply("‚ùå Invalid option. Reply `1-10`.")
            return

        # ROB MODE
        if state["step"] == "rob_select":
            opt = text
            rob_commands = {
                "1": "/rob 200",
                "2": "/rob 150",
                "3": "/rob 100",
                "4": "/rob 50",
                "5": "/rob 1000",
            }
            if opt in rob_commands:
                state["rob_cmd"] = rob_commands[opt]
                state["step"] = "rob_count"
                await message.reply(
                    f"‚úÖ Selected: `{rob_commands[opt]}`.\nHow many users to execute? Reply with number."
                )
            else:
                await message.reply("‚ùå Reply with `1-5`.")
            return

        if state["step"] == "rob_count":
            if not text.isdigit():
                await message.reply("‚ùå Reply with a number.")
                return
            count = int(text)
            scan = LAST_SCAN.get(state["chat_id"])
            pairs = list(scan["user_msgs"].items())[:count] if scan else []
            if not pairs:
                await message.reply("‚ùå No scan data. Use option 1 first.")
                DEVOUR_STATE.pop(user_id, None)
                return
            state["msg_pairs"] = pairs
            state["step"] = "rob_confirm"
            await message.reply(
                f"‚úÖ Will send `{state['rob_cmd']}` to **{count} users**.\nType `yes` to confirm."
            )
            return

        # ATTACK BY MESSAGE LINK FROM ALL ACCOUNTS
        if state["step"] == "attack_message_link":
            link = text
            try:
                chatid_or_username, msg_id = parse_message_link(link)
            except Exception:
                await message.reply(
                    "‚ùå Invalid message link.\nUse `t.me/c/<id>/<msg_id>` or `t.me/<username>/<msg_id>` format."
                )
                DEVOUR_STATE.pop(user_id, None)
                return
            state["attack_msg_link"] = link
            state["attack_chat"] = chatid_or_username
            state["attack_msg_id"] = msg_id
            state["step"] = "attack_text"
            await message.reply("‚úèÔ∏è What message/command to spam? (e.g. `/rob 10000`)")
            return

        if state["step"] == "attack_text":
            custom_text = text
            if not custom_text:
                await message.reply("‚ùå Message text required.")
                return
            state["attack_text"] = custom_text
            state["step"] = "attack_times"
            await message.reply(
                "üî¢ How many times to spam (per account)? (1‚Äì100)\n"
                "This will be executed from **all accounts** in parallel."
            )
            return

        if state["step"] == "attack_times":
            if not text.isdigit():
                await message.reply("‚ùå Reply with a number 1‚Äì100.")
                return
            times = int(text)
            if times < 1 or times > 100:
                await message.reply("‚ùå Number must be between 1 and 100.")
                return
            state["attack_times"] = times
            state["step"] = "attack_link_confirm"
            await message.reply(
                f"Ready! Will spam `{state['attack_text']}` {times} times per account at:\n"
                f"`{state['attack_msg_link']}`\n\nType `yes` to confirm."
            )
            return

        if state["step"] == "attack_link_confirm":
            if text.lower() != "yes":
                await message.reply("‚ùå Type `yes` to execute.")
                return
            ensure_cancel_event()
            state["step"] = "running_attack_links"
            chatid_or_username = state["attack_chat"]
            msg_id = state["attack_msg_id"]
            text_to_send = state["attack_text"]
            times = state["attack_times"]
            try:
                if isinstance(chatid_or_username, str):
                    chat_obj = await client.get_chat(chatid_or_username)
                    chat_id = chat_obj.id
                else:
                    chat_id = chatid_or_username
            except Exception as e:
                await message.reply(f"‚ùå Failed to resolve chat: {e}")
                DEVOUR_STATE.pop(user_id, None)
                return
            
            await message.reply("üöÄ Spamming now from all accounts (in background)...")
            if all_apps:
                task = asyncio.create_task(
                    run_parallel_attacks(all_apps, chat_id, msg_id, text_to_send, times, cancel_event=state["cancel_event"])
                )
                state["background_task"] = task
                state["session_name"] = client.name
                update_current_json(user_id, chat_id, client.name, "message_attack", 0, times * len(all_apps))

                def _done_callback(t):
                    try:
                        remove_current_json(user_id, chat_id, client.name)
                        DEVOUR_STATE.pop(user_id, None)
                    except Exception:
                        pass

                task.add_done_callback(lambda t: _done_callback(t))
            else:
                sent = 0
                reply_text = text_to_send
                try:
                    for _ in range(times):
                        if state.get("cancel_event") and state["cancel_event"].is_set():
                            break
                        try:
                            await client.send_message(chat_id, reply_text, reply_to_message_id=msg_id)
                            sent += 1
                            await asyncio.sleep(0.25)
                        except FloodWait as e:
                            if state.get("cancel_event") and state["cancel_event"].is_set():
                                break
                            await asyncio.sleep(e.value)
                        except Exception:
                            break
                finally:
                    DEVOUR_STATE.pop(user_id, None)
                await message.reply(f"‚úÖ Done! Sent {sent} messages (single-account mode).")
            return

        # SCAN RESULT EXECUTION (simple single-text mode based on REPLY_TEXT1)
        if state["step"] == "await_count":
            if not text.isdigit():
                await message.reply("‚ùå Enter a valid number.")
                return
            count = int(text)
            user_msgs = state.get("user_msgs")
            if not user_msgs:
                await message.reply("‚ùå No user scan loaded.")
                DEVOUR_STATE.pop(user_id, None)
                return
            pairs = list(user_msgs.items())[:count]
            state["step"] = "execution_confirm"
            state["msg_pairs"] = pairs
            await message.reply(
                f"Ready to execute on {count} users using Text1.\nType `yes` to confirm."
            )
            return

        if state["step"] == "execution_confirm":
            if text.lower() != "yes":
                await message.reply("‚ùå Type `yes` to confirm.")
                return
            ensure_cancel_event()
            state["session_name"] = client.name
            chat_id = state["chat_id"]
            pairs = state.get("msg_pairs", [])
            reply_text = REPLY_TEXT1.get(chat_id, REPLY_TEXT1.get("default", "/kill"))
            
            status_msg = await message.reply(f"üöÄ Starting execution...\n‚úÖ Progress: 0/{len(pairs)}")
            update_current_json(user_id, chat_id, client.name, "scan_execution", 0, len(pairs))
            
            sent = 0
            try:
                for idx, (_, msg_id) in enumerate(pairs, 1):
                    if state.get("cancel_event") and state["cancel_event"].is_set():
                        await status_msg.edit(f"üõë Execution cancelled at {sent}/{len(pairs)}.")
                        break
                    try:
                        await client.send_message(chat_id, reply_text, reply_to_message_id=msg_id)
                        sent += 1
                        update_current_json(user_id, chat_id, client.name, "scan_execution", sent, len(pairs))
                        percentage = (sent / len(pairs)) * 100
                        await status_msg.edit(f"‚úÖ Progress: {sent}/{len(pairs)} ({percentage:.1f}%)")
                        await asyncio.sleep(random.uniform(DELAY_RANGE[0], DELAY_RANGE[1]))
                    except FloodWait as e:
                        if state.get("cancel_event") and state["cancel_event"].is_set():
                            break
                        await asyncio.sleep(e.value)
                    except Exception:
                        pass
            finally:
                remove_current_json(user_id, chat_id, client.name)
                DEVOUR_STATE.pop(user_id, None)
            
            await message.reply(f"‚úÖ Done! Message sent to {sent} users.")
            return

        # Batch range: await range input
        if state["step"] == "batch_await_range":
            user_msgs = state.get("user_msgs")
            if not user_msgs:
                await message.reply("‚ùå No scanned data available. Use option 1 first.")
                DEVOUR_STATE.pop(user_id, None)
                return
            total = len(user_msgs)
            raw = text.strip()
            parts = None
            if "-" in raw:
                parts = [p for p in raw.split("-") if p.strip()]
            else:
                parts = raw.split()
            try:
                if len(parts) == 1:
                    end = int(parts[0])
                    start = 1
                elif len(parts) >= 2:
                    start = int(parts[0])
                    end = int(parts[1])
                else:
                    raise ValueError
            except Exception:
                await message.reply("‚ùå Invalid format. Reply like `1 500` or `500`.")
                return
            if start < 1 or end < start or end > total:
                await message.reply(f"‚ùå Invalid range. Valid 1-based range is 1..{total}.")
                return
            pairs_all = list(user_msgs.items())
            selected_pairs = pairs_all[start - 1 : end]
            state["batch_range"] = (start, end)
            state["msg_pairs"] = selected_pairs
            state["step"] = "batch_await_text"
            await message.reply(
                f"‚úÖ Selected {len(selected_pairs)} users (range {start}-{end}).\n\n"
                f"üìù Now send the text to send to all selected users:"
            )
            return

        # Batch: await custom text
        if state["step"] == "batch_await_text":
            batch_text = text
            if not batch_text:
                await message.reply("‚ùå Text required.")
                return
            state["batch_text"] = batch_text
            state["step"] = "batch_confirm"
            pairs = state.get("msg_pairs", [])
            await message.reply(
                f"Ready to send `{batch_text}` to {len(pairs)} selected users.\n"
                f"Type `yes` to confirm."
            )
            return

        # Batch confirm and execute
        if state["step"] == "batch_confirm":
            if text.lower() != "yes":
                await message.reply("‚ùå Type `yes` to confirm.")
                return
            ensure_cancel_event()
            state["session_name"] = client.name
            pairs = state.get("msg_pairs", [])
            chat_id = state["chat_id"]
            batch_text = state.get("batch_text", "/kill")
            
            status_msg = await message.reply(f"üöÄ Starting batch execution...\n‚úÖ Progress: 0/{len(pairs)}")
            update_current_json(user_id, chat_id, client.name, "batch", 0, len(pairs))
            
            sent = 0
            try:
                for idx, (_, msg_id) in enumerate(pairs, 1):
                    if state.get("cancel_event") and state["cancel_event"].is_set():
                        await status_msg.edit(f"üõë Batch cancelled at {sent}/{len(pairs)}.")
                        break
                    try:
                        await client.send_message(chat_id, batch_text, reply_to_message_id=msg_id)
                        sent += 1
                        update_current_json(user_id, chat_id, client.name, "batch", sent, len(pairs))
                        percentage = (sent / len(pairs)) * 100
                        await status_msg.edit(f"‚úÖ Progress: {sent}/{len(pairs)} ({percentage:.1f}%)")
                        await asyncio.sleep(random.uniform(DELAY_RANGE[0], DELAY_RANGE[1]))
                    except FloodWait as e:
                        if state.get("cancel_event") and state["cancel_event"].is_set():
                            break
                        await asyncio.sleep(e.value)
                    except Exception:
                        pass
                try:
                    save_execution_log(chat_id, [], [batch_text], "batch")
                except Exception:
                    pass
            finally:
                remove_current_json(user_id, chat_id, client.name)
                DEVOUR_STATE.pop(user_id, None)
            
            await message.reply(f"‚úÖ Batch done! Message sent to {sent} users.")
            return

        # Simple rob execution
        if state["step"] == "rob_confirm":
            if text.lower() != "yes":
                await message.reply("‚ùå Type `yes` to execute.")
                return
            ensure_cancel_event()
            state["session_name"] = client.name
            pairs = state.get("msg_pairs", [])
            chat_id = state["chat_id"]
            rob_cmd = state["rob_cmd"]
            
            status_msg = await message.reply(f"üöÄ Starting rob execution...\n‚úÖ Progress: 0/{len(pairs)}")
            update_current_json(user_id, chat_id, client.name, "rob", 0, len(pairs))
            
            sent = 0
            try:
                for idx, (_, msg_id) in enumerate(pairs, 1):
                    if state.get("cancel_event") and state["cancel_event"].is_set():
                        await status_msg.edit(f"üõë Rob execution cancelled at {sent}/{len(pairs)}.")
                        break
                    try:
                        await client.send_message(chat_id, rob_cmd, reply_to_message_id=msg_id)
                        sent += 1
                        update_current_json(user_id, chat_id, client.name, "rob", sent, len(pairs))
                        percentage = (sent / len(pairs)) * 100
                        await status_msg.edit(f"‚úÖ Progress: {sent}/{len(pairs)} ({percentage:.1f}%)")
                        await asyncio.sleep(random.uniform(DELAY_RANGE[0], DELAY_RANGE[1]))
                    except FloodWait as e:
                        if state.get("cancel_event") and state["cancel_event"].is_set():
                            break
                        await asyncio.sleep(e.value)
                    except Exception:
                        pass
            finally:
                remove_current_json(user_id, chat_id, client.name)
                DEVOUR_STATE.pop(user_id, None)
            
            await message.reply(f"‚úÖ Done! `{rob_cmd}` sent to {sent} users.")
            return

    # ========== BASIC COMMANDS ==========

    @app.on_message(filters.command("addacc") & sudo_filter & filters.private)
    async def addacc(client, message):
        parts = message.text.split(" ", 2)
        if len(parts) < 3:
            await message.reply(
                "‚ùå **Usage:** `/addacc <name> <session_string>`\n"
                "Example: `/addacc acc1 BQAbc123...xyz`"
            )
            return
        name, session_string = parts[1].strip(), parts[2].strip()
        if any(s["name"].lower() == name.lower() for s in SESSIONS):
            await message.reply(f"‚ùå Account with name `{name}` already exists!")
            return
        SESSIONS.append({"name": name, "session_string": session_string})
        save_data()
        if all_apps is not None:
            await add_new_session(all_apps, name, session_string)
            await message.reply(f"‚úÖ Account `{name}` added & started (no restart needed).")
        else:
            await message.reply(f"‚úÖ Account `{name}` added. Restart to activate.")

    @app.on_message(filters.command("delacc") & sudo_filter & filters.private)
    async def delacc(client, message):
        parts = message.text.split(" ", 1)
        if len(parts) < 2:
            await message.reply("‚ùå **Usage:** `/delacc <name>`")
            return
        name = parts[1].strip()
        if not any(s["name"] == name for s in SESSIONS):
            await message.reply(f"‚ùå No such account: {name}")
            return
        if all_apps is not None:
            await remove_session(all_apps, name)
            await message.reply(f"‚úÖ Account `{name}` removed and stopped.")
        else:
            await message.reply("Account removed. Please restart for changes to take effect.")

    @app.on_message(filters.command("joinchat") & sudo_filter & filters.private)
    async def joinchat(client, message):
        parts = message.text.split(" ", 1)
        if len(parts) < 2:
            await message.reply("‚ùå **Usage:** `/joinchat <invite_link>`")
            return
        try:
            chat = await client.join_chat(parts[1].strip())
            await message.reply(f"‚úÖ Joined **{chat.title or chat.id}**.")
        except Exception as e:
            await message.reply(f"‚ùå Error: {e}")

    @app.on_message(filters.command(["cancel", "stop"]) & sudo_filter & filters.private)
    async def cancel(client, message):
        user_id = message.from_user.id
        state = DEVOUR_STATE.get(user_id)
        if not state:
            await message.reply("‚ÑπÔ∏è No active task to cancel.")
            return
        cancel_event = state.get("cancel_event")
        if not cancel_event:
            cancel_event = asyncio.Event()
            state["cancel_event"] = cancel_event
        cancel_event.set()
        bg = state.get("background_task")
        if bg and isinstance(bg, asyncio.Task) and not bg.done():
            try:
                bg.cancel()
            except Exception:
                pass
            state["background_task"] = None
        state["cancelled"] = True
        await message.reply("üõë Cancellation requested. Stopping the current task...")

    @app.on_message(filters.command("settext1") & sudo_filter & filters.private)
    async def settext1(client, message):
        parts = message.text.split(" ", 1)
        if len(parts) == 2 and parts[1].strip():
            REPLY_TEXT1[message.chat.id] = parts[1].strip()
            save_data()
            await message.reply(f"‚úÖ **Text1 set to:** `{parts[1].strip()}`")
        else:
            await message.reply("‚ùå **Usage:** `/settext1 <text>`")

    @app.on_message(filters.command("settext2") & sudo_filter & filters.private)
    async def settext2(client, message):
        parts = message.text.split(" ", 1)
        if len(parts) == 2 and parts[1].strip():
            REPLY_TEXT2[message.chat.id] = parts[1].strip()
            save_data()
            await message.reply(f"‚úÖ **Text2 set to:** `{parts[1].strip()}`")
        else:
            await message.reply("‚ùå **Usage:** `/settext2 <text>`")

    @app.on_message(filters.command("delall") & sudo_filter & filters.private)
    async def delall(client, message):
        user_id = message.from_user.id
        state = DEVOUR_STATE.get(user_id)
        if not state or "chat_id" not in state:
            await message.reply("‚ùå Set a target chat via /devour first.")
            return
        chat_id = state["chat_id"]
        status = await message.reply("üóë Deleting all my messages from group...")
        deleted_count = 0
        async for msg in client.get_chat_history(chat_id):
            if msg.from_user and msg.from_user.is_self:
                try:
                    await client.delete_messages(chat_id, msg.id)
                    deleted_count += 1
                    await asyncio.sleep(0.1)
                except Exception:
                    pass
        await status.edit(f"‚úÖ Done! Deleted {deleted_count} messages.")
        await message.reply("‚úÖ All my messages removed from group.")

    @app.on_message(filters.command("claim") & sudo_filter & filters.private)
    async def claim(client, message):
        await message.reply("‚è≥ Claiming `/daily` from all accounts in @im_bakabot...")
        failed = 0
        for sess in SESSIONS:
            try:
                temp_app = None
                if all_apps:
                    for a in all_apps:
                        if a.name == sess["name"]:
                            temp_app = a
                            break
                if temp_app is None:
                    temp_app = Client(
                        sess["name"],
                        api_id=API_ID,
                        api_hash=API_HASH,
                        session_string=sess["session_string"],
                    )
                    await temp_app.start()
                await temp_app.send_message(PERSONAL_BOT, "/daily")
                if all_apps is None or temp_app not in all_apps:
                    await temp_app.stop()
                await asyncio.sleep(2)
            except Exception:
                failed += 1
        await message.reply(
            f"‚úÖ `/daily` claimed in @im_bakabot.\nAccounts: {len(SESSIONS)}, Failed: {failed}"
        )

    @app.on_message(filters.command("help") & sudo_filter & filters.private)
    async def help_msg(client, message):
        await message.reply(
            "**ü§ñ Devour UserBot Help:**\n\n"
            "**DM Commands:**\n"
            "`/devour` - Open main control menu\n"
            "`/settext1 <text>` - Set Text1\n"
            "`/settext2 <text>` - Set Text2\n"
            "`/joinchat <link>` - Join group/channel\n"
            "`/addacc <name> <session>` - Add new account (hot add)\n"
            "`/delacc <name>` - Remove account (hot remove)\n"
            "`/delall` - Delete all my messages from target group\n"
            "`/claim` - Call `/daily` from all accounts in @im_bakabot\n"
            "`/cancel`, `/stop` - Cancel current task\n"
            "`/delay <min> <max>` - Set delay range (e.g. `/delay 4 6`)\n"
            "`/current` - Show all currently running executions\n"
            "`/help` - Show this help\n\n"
            f"**Data:** `{DATA_FILE}` | **Active accounts:** {len(SESSIONS)}\n"
            f"**Current delay:** `{DELAY_RANGE[0]}-{DELAY_RANGE[1]}` seconds"
        )

async def main():
    load_data()
    load_current_json()
    if not SESSIONS:
        print("‚ùå No sessions found! Add sessions using /addacc in DM or edit devour.json")
        print("Creating sample devour.json structure...")
        save_data()
        return
    apps = []
    for sess in SESSIONS:
        app = Client(
            sess["name"],
            api_id=API_ID,
            api_hash=API_HASH,
            session_string=sess["session_string"],
        )
        _attach_attack_method(app)
        register_handlers(app, apps)
        apps.append(app)
    print(f"ü§ñ Running {len(apps)} session(s) with DM-based control.")
    print(f"üíæ Data file: {DATA_FILE}")
    print(f"üìä Current file: {CURRENT_FILE}")
    print(f"üë§ Sudo users: {SUDO_USERS}")
    print(f"‚è±Ô∏è  Delay range: {DELAY_RANGE[0]}-{DELAY_RANGE[1]} seconds")
    await asyncio.gather(*[a.start() for a in apps])
    await asyncio.get_event_loop().create_future()

if __name__ == "__main__":
    asyncio.run(main())
